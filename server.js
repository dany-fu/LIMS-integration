// Author: Dany Fu (danyfu@bu.edu)

const axios = require("axios").default;
const csv = require("fast-csv");
const fs = require("fs");
const argv = require("minimist")(process.argv.slice(2));
const config = require('config');
const constants = require("./constants.js");

/*****************
 * Logging
 * @type {winston}
 *****************/
const { createLogger, format, transports } = require('winston');
const { combine, timestamp, printf } = format;
const myFormat = printf(({ level, message, timestamp }) => {
  return `{${timestamp} ${level}: ${message}}`;
});
let today = new Date().toLocaleDateString("en-US", {timeZone: "America/New_York"});
let todayFormatted = today.substring(0, 10).replace(/\//g, "-");
let now = new Date().toLocaleString("en-US", {timeZone: "America/New_York"});
const logger = createLogger({
  format: combine(
    timestamp({
      format: now
    }),
    myFormat
  ),
  level: 'info',
  transports: [
    // - Write all logs with level `error` and below to `error.log`
    new transports.File({ filename: `logs/error-${todayFormatted}.log`, level: 'error' }),
    // - Write all logs with level `info` and below to `combined.log`
    new transports.File({ filename: `logs/combined-${todayFormatted}.log` }),
  ],
});


/*******************
 * HELPER FUNCTIONS
 *******************/
function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

function equalsIgnoringCase(text, other) {
  return text.localeCompare(other, undefined, { sensitivity: 'accent' }) === 0;
}

function getNumAttempts(patientSample){
  return patientSample.data[0].meta.find(m => m.key === constants.META.NUM_ATTEMPTS).value;
}

function getSampleId(patientSample){
  return patientSample.data[0].sampleID;
}

function makeSearchURIObject(metas, plateBC, wellNum){
  const pcrBC = metas.find(m => m.key === constants.META.QPCR_PLATE_BC);
  const pcrWN = metas.find(m => m.key === constants.META.QPCR_PLATE_WELL_NUM);
  return encodeURIComponent(`[{` +
    `"sampleTypeMetaID": ${pcrBC.sampleTypeMetaID},` +
    `"metaValue": "${plateBC}"` +
    `}, {` +
    `"sampleTypeMetaID": ${pcrWN.sampleTypeMetaID},` +
    `"metaValue": "${wellNum}"` +
  `}]`);
}

/**
 * Get the barcode of the plate by searching for "# Barcode: " in the QuantStudio output
 * @param logfile QuantStudio or Hamilton logfile
 * @returns {string} barcode of the qPCR plate, if found, else empty string
 */
function getqPCRPlateBC(logfile) {
  let barcode = "";
  let data = fs.readFileSync(logfile, 'utf8');
  const regex = /# Barcode: (.*)/g;
  let found = regex.exec(data);
  if(found){
    barcode = found[1];
  }
  return barcode;
}

function stringToArray(str){
  str = str.replace(/'|"/g, "");
  return str.replace(/^\[|\]$/g, "").split(",");
}


/******************
 * ELABS API CALLS
 ******************/

/**
 * Authentication; this function must occur before any other API calls can be made
 * @returns {Promise<T>} A token is returned if the login is successful
 */
async function login() {

  return axios
    .post(config.get('endpoints.login'), {
      username: config.get('username'),
      password: config.get('password'),
    })
    .then((res) => {
      logger.info(`Authentication status code: ${res.status}`);
      if(res.status === 200){
        axios.defaults.headers.common['Authorization'] = res.data.token;
      }
      return res.status;
    })
    .catch((error) => {
      logger.error(`Failed to authenticate with message: ${error.response.data.message}
                    Error: ${error.response.data.errors}`);
      process.exitCode = 8;
      return null;
    });
}

/**
 * Update a custom field for a Covid-19 sample
 * @param sampleId The unique ID of the sample generated by eLabs
 * @param key Name of the field to be updated
 * @param value Value of the field to be updated
 * @param type The field type (dropdown, text, radio button, etc)
 * @param metaId The sampleTypeMetaID
 * @returns {Promise<void>}
 */
async function updateMeta({sampleId, key, value, type, metaId}={}){
  return axios
    .put(`${config.get('endpoints.samples')}/${sampleId}/meta`, {
      key: key,
      value: value,
      sampleDataType: type,
      sampleTypeMetaID: metaId
    })
    .then((res) => {
      if(res.status === 200){
        logger.info(`Update sample: ${sampleId}, field:${key}, statusCode: ${res.status}`);
      } else {
        logger.error(res.data);
        process.exitCode = 8;
      }
    })
    .catch((error) => {
      logger.error(`Failed to update sample meta: ${error.response.data.message}
                    Error: ${error.response.data.errors}`);
      process.exitCode = 8;
    });
}

/**
 * Search for a Covid-19 sample in a specific well of a qPCR plate
 * @param metas Array of meta fields associated with the COVID-19 SampleType
 * @param plateBC
 * @param wellNum
 * @returns {Promise<void>}
 */
async function searchForPatienSample(metas, plateBC, wellNum){
  let searchParams = makeSearchURIObject(metas, plateBC, wellNum);
  let endpoint = `${config.get('endpoints.samples')}` +
    `?$expand=meta&sampleTypeID=${config.get('covidSampleTypeId')}` +
    `&filterBySampleTypeMetaValues=${searchParams}`;

  return axios.get(endpoint)
    .then((res) => {
      if(res.status === 200){
        if(res.data.data.length === 0){
          process.exitCode = 8;
          logger.error(`No sample found in well ${wellNum} of qPCR plate ${plateBC}`);
          return null;
        }
        else if(res.data.data.length === 1){
          logger.info(`Found sample ${getSampleId(res.data)} in well ${wellNum} on qPCR plate ${plateBC}`);
          return res.data;
        } else {
          logger.error(`More than one sample found in well ${wellNum} of qPCR plate ${plateBC}`);
          process.exitCode = 8;
          return null;
        }
      } else{
        logger.error(res.data);
        process.exitCode = 8;
        return null;
      }
    })
    .catch((error) => {
      logger.error(`Failed to find sample with message: ${error.response.data.message}
                    Error: ${error.response.data.errors}`);
      process.exitCode = 8;
      return null;
    });
}

/**
 * Find a Covid-19 Sample with the given barcode (which is also its name)
 * Returns null if more than one sample can be found with the same barcode
 * @param barcode Name of the sample
 * @returns {Promise<void>} Sample object with all custom fields if found, else Null
 */
async function getPatientSample(barcode){
  let endpoint = `${config.get('endpoints.samples')}?$expand=meta&sampleTypeID=${config.get('covidSampleTypeId')}&name=${barcode}`;
  return axios.get(endpoint)
    .then((res) => {
      if(res.status === 200){
        if(res.data.data.length === 0){
          process.exitCode = 8;
          logger.error(`Sample for barcode ID ${barcode} not found`);
          return null;
        }
        else if(res.data.data.length === 1){
          logger.info(`Got sample with barcode ${barcode}, statusCode: ${res.status}`);
          return res.data;
        } else {
          logger.error(`More than one sample found with name ${barcode}`);
          process.exitCode = 8;
          return null;
        }
      } else{
        logger.error(res.data);
        process.exitCode = 8;
        return null;
      }
    })
    .catch((error) => {
      logger.error(`Failed to get sample: ${barcode} with message: ${error.response.data.message}
                    Error: ${error.response.data.errors}`);
      process.exitCode = 8;
      return null;
    });
}

/**
 * Get all the meta fields for COVID-19 SampleType
 * The sampleTypeId is pulled from config
 * @returns {Promise<T>}
 */
async function getCovidSampleTypeMetas(){
  return axios.get(`${config.get('endpoints.sampleTypes')}/${config.get('covidSampleTypeId')}/meta`)
    .then((res) => {
      if(res.status === 200){
        logger.info(`Got COVID-19 sampleType, statusCode: ${res.status}`);
        return res.data.data;
      } else {
        logger.error(`Got statusCode when fetching sample type: ${res.status}`);
        process.exitCode = 8;
        return null;
      }
    })
    .catch((error) => {
      logger.error(`Failed to find sample with message: ${error.response.data.message}
                    Error: ${error.response.data.errors}`);
      process.exitCode = 8;
      return null;
    });
}



/******************************
 * HAMILTON RELATED FUNCTIONS
 ******************************/

/**
 * Update Covid-19 Sample with the plate barcode and well number
 * from the Sample Prep Hamilton and update status
 * @param sampleID Unique ID of the sample in eLabs
 * @param destBC
 * @param destWellNum
 * @param metas Array of meta fields associated with the COVID-19 SampleType
 * @returns {Promise<void>}
 */
async function samplePrepTracking(sampleID, destBC, destWellNum, metas){

  const dwBC = metas.find(m => m.key === constants.META.DEEPWELL_BC);
  updateMeta({sampleId:sampleID,
    key: constants.META.DEEPWELL_BC,
    value: destBC,
    type: dwBC.sampleDataType,
    metaId: dwBC.sampleTypeMetaID}); //update RNA Plate Barcode

  const dwWN = metas.find(m => m.key === constants.META.DEEPWELL_WELL_NUM);
  updateMeta({sampleId:sampleID,
    key: constants.META.DEEPWELL_WELL_NUM,
    value: destWellNum,
    type: dwWN.sampleDataType,
    metaId: dwWN.sampleTypeMetaID}); //update RNA Plate Well Location

  const status = metas.find(m => m.key === constants.META.STATUS);
  updateMeta({sampleId:sampleID,
    key: constants.META.STATUS,
    value: constants.STATUS_VAL.SAMPLE_PREP_DONE,
    type: status.sampleDataType,
    metaId: status.sampleTypeMetaID}); //update status to "Sample Transferred To 96-Well Plate"
}

/**
 * Updates Covid-19 Sample with the plate barcode and well number
 * from the RNA Extraction Hamilton and update status
 * @param sampleID Unique ID of the sample in eLabs
 * @param destBC
 * @param destWellNum
 * @param metas Array of meta fields associated with the COVID-19 SampleType
 * @returns {Promise<void>}
 */
async function rnaExtractionTracking(sampleID, destBC, destWellNum, metas){

  const rnaBC = metas.find(m => m.key === constants.META.RNA_PLATE_BC);
  updateMeta({sampleId:sampleID,
    key: constants.META.RNA_PLATE_BC,
    value: destBC,
    type: rnaBC.sampleDataType,
    metaId: rnaBC.sampleTypeMetaID}); //update RNA Plate Barcode

  const rnaWN = metas.find(m => m.key === constants.META.RNA_PLATE_WELL_NUM);
  updateMeta({sampleId:sampleID,
    key: constants.META.RNA_PLATE_WELL_NUM,
    value: destWellNum,
    type: rnaWN.sampleDataType,
    metaId: rnaWN.sampleTypeMetaID}); //update RNA Plate Well Location

  const status = metas.find(m => m.key === constants.META.STATUS);
  updateMeta({sampleId:sampleID,
    key: constants.META.STATUS,
    value: constants.STATUS_VAL.RNA_DONE,
    type: status.sampleDataType,
    metaId: status.sampleTypeMetaID}); //update status to "RNA Extracted"
}

/**
 * Updates Covid-19 Sample with the plate barcode and well number
 * from the qPCR Prep Hamilton and update status
 * @param sampleID Unique ID of the sample in eLabs
 * @param destBC
 * @param destWellNum
 * @param metas Array of meta fields associated with the COVID-19 SampleType
 * @returns {Promise<void>}
 */
function qPCRPrepTracking(sampleID, destBC, destWellNum, metas){

  const pcrBC = metas.find(m => m.key === constants.META.QPCR_PLATE_BC);
  updateMeta({sampleId:sampleID,
    key: constants.META.QPCR_PLATE_BC,
    value: destBC,
    type: pcrBC.sampleDataType,
    metaId: pcrBC.sampleTypeMetaID}); //update RNA Plate Barcode

  const pcrWN = metas.find(m => m.key === constants.META.QPCR_PLATE_WELL_NUM);
  updateMeta({sampleId:sampleID,
    key: constants.META.QPCR_PLATE_WELL_NUM,
    value: destWellNum,
    type: pcrWN.sampleDataType,
    metaId: pcrWN.sampleTypeMetaID}); //update RNA Plate Well Location

  const status = metas.find(meta => meta.key === constants.META.STATUS);
  updateMeta({sampleId:sampleID,
    key: constants.META.STATUS,
    value: constants.STATUS_VAL.QPCR_PREP_DONE,
    type: status.sampleDataType,
    metaId: status.sampleTypeMetaID}); //update status to "qPCR Reactions Prepared"
}

/**
 * Updates a Covid-19 Sample with the reagent lot number it was processed with
 * @param sampleID
 * @param reagentNames Array of reagent names used
 * @param reagentNums Array of reagent lot numbers, matches the names by index
 * @param metas Array of meta fields associated with the COVID-19 SampleType
 */
function reagentTracking(sampleID, reagentNames, reagentNums, metas){
  reagentNames = stringToArray(reagentNames);
  reagentNums = stringToArray(reagentNums);

  if(reagentNames.length !== reagentNums.length){
    logger.error(`Length of reagent names do not match length of reagent lot numbers for sample ${sampleID}`);
    process.exitCode = 8;
    return null;
  }
  for (let i = 0; i < reagentNames.length; i++) {
    const reagentMeta = metas.find(meta => meta.key === reagentNames[i]);
    if(reagentMeta){
      updateMeta({sampleId:sampleID,
        key: reagentNames[i],
        value: reagentNums[i],
        type: reagentMeta.sampleDataType,
        metaId: reagentMeta.sampleTypeMetaID}); //Update reagent lot number
    } else {
      logger.error(`Reagent field ${reagentNames[i]} cannot be found for sample ${sampleID}`);
      process.exitCode = 8;
      return null;
    }

  }
}

/**
 * Calls the appropriate update function based on Hamilton protocol
 * @param sampleID
 * @param destBC Output barcode
 * @param destWellNum Output well number
 * @param metas Array of meta fields associated with the COVID-19 SampleType
 * @param protocol A string indicating which robot the log originated from
 */
function lineageTracking(sampleID, destBC, destWellNum, metas, protocol){
  switch(protocol){
    case constants.ORIGIN_VAL.SAMPLE_PREP:
      samplePrepTracking(sampleID, destBC, destWellNum, metas);
      break;
    case constants.ORIGIN_VAL.RNA_EXTRACTION:
      rnaExtractionTracking(sampleID, destBC, destWellNum, metas);
      break;
    case constants.ORIGIN_VAL.QPCR_PREP:
      qPCRPrepTracking(sampleID, destBC, destWellNum, metas);
      break;
  }
}

/**
 * Get data from each row of the Hamilton log and calls the appropriate function
 * to update eLabs records
 * @param csvRow
 * @param metas Array of meta fields associated with the COVID-19 SampleType
 * @returns {Promise<void>}
 */
async function hamiltonTracking(csvRow, metas){
  let protocol = csvRow[constants.HAMILTON_LOG_HEADERS.PROTOCOL];
  if (!protocol || (!(protocol in constants.ORIGIN_VAL))){
    let protocolVals = Object.keys(constants.ORIGIN_VAL);
    logger.error(`${protocol} is not recognized as a supported process. Must be one of the
                  ${protocolVals.length} values: ${Object.keys(constants.ORIGIN_VAL)}.
                  Index ${csvRow[constants.HAMILTON_LOG_HEADERS.INDEX]} not processed.`);
    process.exitCode = 8;
    return;
  }

  let sampleBC = csvRow[constants.HAMILTON_LOG_HEADERS.SAMPLE_TUBE_BC];
  let sampleObj = await getPatientSample(sampleBC);
  if(!sampleObj){
    process.exitCode = 8;
    return;
  }

  let sampleID = getSampleId(sampleObj);
  let reagentNames = csvRow[constants.HAMILTON_LOG_HEADERS.REAGENT_NAMES];
  let reagentNums = csvRow[constants.HAMILTON_LOG_HEADERS.REAGENT_NUMS];
  reagentTracking(sampleID, reagentNames, reagentNums, metas);


  let destBC = csvRow[constants.HAMILTON_LOG_HEADERS.DEST_BC];
  let destWellNum = csvRow[constants.HAMILTON_LOG_HEADERS.DEST_WELL_NUM];
  lineageTracking(sampleID, destBC, destWellNum, metas, protocol);
}


/********************************
 * QUANTSTUDIO RELATED FUNCTIONS
 ********************************/

/**
 * Update "call" of the test, results can be POSITIVE, NEGATIVE, INVALID, INCONCLUSIVE, or WARNING
 * INVALID or INCONCLUSIVE results both require recollection of sample
 * WARNING occurs when controls failed, and can be reattempted up to 1 more time
 * If controls fail during attempt #2, a recollection is required
 * @param csvRow
 * @param qPCRPlateBC
 * @param metas Array of meta fields associated with the COVID-19 SampleType
 * @returns {Promise<void>}
 */
async function updateTestResult(csvRow, qPCRPlateBC, metas){
  let wellNum = csvRow[constants.QPCR_LOG_HEADERS.WELL];
  let sampleObj = await searchForPatienSample(metas, qPCRPlateBC, wellNum);
  if(!sampleObj){
    process.exitCode = 8;
    return;
  }

  let sampleID = getSampleId(sampleObj);
  let call = csvRow[constants.QPCR_LOG_HEADERS.CALL];

  const result = metas.find(m => m.key === constants.META.RESULT);
  updateMeta({sampleId:sampleID,
    key: constants.META.RESULT,
    value: constants.TEST_RESULT[call],
    type: result.sampleDataType,
    metaId: result.sampleTypeMetaID}); //update COVID-19 Test Result


  const status = metas.find(m => m.key === constants.META.STATUS);
  updateMeta({sampleId:sampleID,
    key: constants.META.STATUS,
    value: constants.STATUS_VAL.QPCR_DONE,
    type: status.sampleDataType,
    metaId: status.sampleTypeMetaID}); //update status to "qPCR Complete"

  let numAttempt = getNumAttempts(sampleObj);
  if (numAttempt < 2){
    const attemptMeta = metas.find(m => m.key === constants.META.NUM_ATTEMPTS);
    updateMeta({sampleId:sampleID,
      key: constants.META.NUM_ATTEMPTS,
      value: ++numAttempt,
      type: attemptMeta.sampleDataType,
      metaId: attemptMeta.sampleTypeMetaID}); //Increase number of attempts by 1, if allowed
  }
}

/**
 * Updates PatientSample with CT values from the QuantStudio
 * @param csvRow
 * @param qPCRPlateBC
 * @param metas Array of meta fields associated with the COVID-19 SampleType
 * @param sampleIdDict Mapping of well num to sample id
 * @returns {Promise<void>}
 */
async function updateCTValues(csvRow, qPCRPlateBC, metas, sampleIdDict){
  let sampleID;
  let wellNum = csvRow[constants.QPCR_LOG_HEADERS.WELL];
  if (wellNum in sampleIdDict){
    sampleID = sampleIdDict[wellNum];
  } else {
    let sampleObj = await searchForPatienSample(metas, qPCRPlateBC, wellNum);
    if(!sampleObj){
      process.exitCode = 8;
      return;
    }
    sampleID = getSampleId(sampleObj);
    sampleIdDict[wellNum] = sampleID;
  }

  let target = csvRow[constants.QPCR_LOG_HEADERS.TARGET];
  let cq = csvRow[constants.QPCR_LOG_HEADERS.CQ];

  const targetMeta = metas.find(m => m.key === constants.META[target]);
  updateMeta({sampleId:sampleID,
    key: constants.META[target],
    value: cq,
    type: targetMeta.sampleDataType,
    metaId: targetMeta.sampleTypeMetaID}); //update CT value
}

async function parse_logfile(logfile){
  logger.info(logfile);

  let auth = await login();
  if (!auth || auth !== 200){
    logger.error(`Failed to log into eLabs.`);
    process.exitCode = 8;
    return;
  }

  let metas = await getCovidSampleTypeMetas();
  if (!metas){
    process.exitCode = 8;
    return;
  }

  let sampleIdDict = {};
  let qPCRPlateBC = getqPCRPlateBC(logfile);

  let readStream = fs.createReadStream(logfile);
  readStream.pipe(csv.parse({
      headers:true,
      comment:"#", //ignore lines that begin with #
      skipLines:2 })
    )
    .on('error', (error) => {
      logger.error(error);
      process.exitCode = 8;
      readStream.destroy();
    })
    .on('data', (row) => {
      if (Object.keys(row).includes(constants.HAMILTON_LOG_HEADERS.PROTOCOL)){
        hamiltonTracking(row, metas);
      } else {
        if (qPCRPlateBC.length === 0){
          logger.error("No qPCR plate barcode was found");
          process.exitCode = 8;
          readStream.destroy();
          return;
        }

        if (Object.keys(row).includes(constants.QPCR_LOG_HEADERS.CQ)){
          updateCTValues(row, qPCRPlateBC, metas, sampleIdDict);
        } else if (Object.keys(row).includes(constants.QPCR_LOG_HEADERS.CALL)){
          updateTestResult(row, qPCRPlateBC, metas);
        }
      }

    })
    .on('end', (rowCount) => logger.info(`Parsed ${rowCount} records`));
}

/**
 * file: path of the CSV file to be parsed
 */
parse_logfile(argv.file);
process.on('exit', (code) => {
  console.log(`Exited with code ${code}`);
  logger.info(`Process exit event with code:${code}`);
});

//for testing
module.exports = {
  login: login,
  getCovidSampleTypeMetas: getCovidSampleTypeMetas,
  qPCRPrepTracking: qPCRPrepTracking
};
